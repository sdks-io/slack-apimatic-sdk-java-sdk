/*
 * SlackWebApiLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.slack.apis;

import com.slack.ApiHelper;
import com.slack.Server;
import com.slack.exceptions.ApiException;
import com.slack.exceptions.ChatDeleteErrorSchemaException;
import com.slack.exceptions.ChatDeleteScheduledMessageErrorSchemaException;
import com.slack.exceptions.ChatGetPermalinkErrorSchemaException;
import com.slack.exceptions.ChatMeMessageErrorSchemaException;
import com.slack.exceptions.ChatPostEphemeralErrorSchemaException;
import com.slack.exceptions.ChatPostMessageErrorSchemaException;
import com.slack.exceptions.ChatScheduleMessageErrorSchemaException;
import com.slack.exceptions.ChatUnfurlErrorSchemaException;
import com.slack.exceptions.ChatUpdateErrorSchemaException;
import com.slack.http.request.HttpMethod;
import com.slack.http.response.ApiResponse;
import com.slack.models.ChatDeleteScheduledMessageSchema;
import com.slack.models.ChatDeleteSuccessSchema;
import com.slack.models.ChatGetPermalinkSuccessSchema;
import com.slack.models.ChatMeMessageSchema;
import com.slack.models.ChatPostEphemeralSuccessSchema;
import com.slack.models.ChatPostMessageSuccessSchema;
import com.slack.models.ChatScheduleMessageSuccessSchema;
import com.slack.models.ChatUnfurlSuccessSchema;
import com.slack.models.ChatUpdateSuccessSchema;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import io.apimatic.coreinterfaces.http.request.ResponseClassType;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class ChatApi extends BaseApi {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public ChatApi(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Deletes a message.
     * @param  token  Optional parameter: Authentication token. Requires scope: `chat:write`
     * @param  ts  Optional parameter: Timestamp of the message to be deleted.
     * @param  channel  Optional parameter: Channel containing the message to be deleted.
     * @param  asUser  Optional parameter: Pass true to delete the message as the authed user with
     *         `chat:write:user` scope. [Bot users](/bot-users) in this context are considered
     *         authed users. If unused or false, the message will be deleted with `chat:write:bot`
     *         scope.
     * @return    Returns the ChatDeleteSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatDeleteSuccessSchema> chatDelete(
            final String token,
            final Double ts,
            final String channel,
            final Boolean asUser) throws ApiException, IOException {
        return prepareChatDeleteRequest(token, ts, channel, asUser).execute();
    }

    /**
     * Deletes a message.
     * @param  token  Optional parameter: Authentication token. Requires scope: `chat:write`
     * @param  ts  Optional parameter: Timestamp of the message to be deleted.
     * @param  channel  Optional parameter: Channel containing the message to be deleted.
     * @param  asUser  Optional parameter: Pass true to delete the message as the authed user with
     *         `chat:write:user` scope. [Bot users](/bot-users) in this context are considered
     *         authed users. If unused or false, the message will be deleted with `chat:write:bot`
     *         scope.
     * @return    Returns the ChatDeleteSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatDeleteSuccessSchema>> chatDeleteAsync(
            final String token,
            final Double ts,
            final String channel,
            final Boolean asUser) {
        try {
            return prepareChatDeleteRequest(token, ts, channel, asUser).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatDelete.
     */
    private ApiCall<ApiResponse<ChatDeleteSuccessSchema>, ApiException> prepareChatDeleteRequest(
            final String token,
            final Double ts,
            final String channel,
            final Boolean asUser) {
        return new ApiCall.Builder<ApiResponse<ChatDeleteSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.delete")
                        .formParam(param -> param.key("ts")
                                .value(ts).isRequired(false))
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("as_user")
                                .value(asUser).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatDeleteSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ChatDeleteErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a pending scheduled message from the queue.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: The channel the scheduled_message is posting to
     * @param  scheduledMessageId  Required parameter: `scheduled_message_id` returned from call to
     *         chat.scheduleMessage
     * @param  asUser  Optional parameter: Pass true to delete the message as the authed user with
     *         `chat:write:user` scope. [Bot users](/bot-users) in this context are considered
     *         authed users. If unused or false, the message will be deleted with `chat:write:bot`
     *         scope.
     * @return    Returns the ChatDeleteScheduledMessageSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatDeleteScheduledMessageSchema> chatDeleteScheduledMessage(
            final String token,
            final String channel,
            final String scheduledMessageId,
            final Boolean asUser) throws ApiException, IOException {
        return prepareChatDeleteScheduledMessageRequest(token, channel, scheduledMessageId,
                asUser).execute();
    }

    /**
     * Deletes a pending scheduled message from the queue.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: The channel the scheduled_message is posting to
     * @param  scheduledMessageId  Required parameter: `scheduled_message_id` returned from call to
     *         chat.scheduleMessage
     * @param  asUser  Optional parameter: Pass true to delete the message as the authed user with
     *         `chat:write:user` scope. [Bot users](/bot-users) in this context are considered
     *         authed users. If unused or false, the message will be deleted with `chat:write:bot`
     *         scope.
     * @return    Returns the ChatDeleteScheduledMessageSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatDeleteScheduledMessageSchema>> chatDeleteScheduledMessageAsync(
            final String token,
            final String channel,
            final String scheduledMessageId,
            final Boolean asUser) {
        try {
            return prepareChatDeleteScheduledMessageRequest(token, channel, scheduledMessageId,
            asUser).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatDeleteScheduledMessage.
     */
    private ApiCall<ApiResponse<ChatDeleteScheduledMessageSchema>, ApiException> prepareChatDeleteScheduledMessageRequest(
            final String token,
            final String channel,
            final String scheduledMessageId,
            final Boolean asUser) {
        return new ApiCall.Builder<ApiResponse<ChatDeleteScheduledMessageSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.deleteScheduledMessage")
                        .formParam(param -> param.key("channel")
                                .value(channel))
                        .formParam(param -> param.key("scheduled_message_id")
                                .value(scheduledMessageId))
                        .formParam(param -> param.key("as_user")
                                .value(asUser).isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatDeleteScheduledMessageSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response if no message is found",
                                (reason, context) -> new ChatDeleteScheduledMessageErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Retrieve a permalink URL for a specific extant message.
     * @param  token  Required parameter: Authentication token. Requires scope: `none`
     * @param  channel  Required parameter: The ID of the conversation or channel containing the
     *         message
     * @param  messageTs  Required parameter: A message's `ts` value, uniquely identifying it within
     *         a channel
     * @return    Returns the ChatGetPermalinkSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatGetPermalinkSuccessSchema> chatGetPermalink(
            final String token,
            final String channel,
            final String messageTs) throws ApiException, IOException {
        return prepareChatGetPermalinkRequest(token, channel, messageTs).execute();
    }

    /**
     * Retrieve a permalink URL for a specific extant message.
     * @param  token  Required parameter: Authentication token. Requires scope: `none`
     * @param  channel  Required parameter: The ID of the conversation or channel containing the
     *         message
     * @param  messageTs  Required parameter: A message's `ts` value, uniquely identifying it within
     *         a channel
     * @return    Returns the ChatGetPermalinkSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatGetPermalinkSuccessSchema>> chatGetPermalinkAsync(
            final String token,
            final String channel,
            final String messageTs) {
        try {
            return prepareChatGetPermalinkRequest(token, channel, messageTs).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatGetPermalink.
     */
    private ApiCall<ApiResponse<ChatGetPermalinkSuccessSchema>, ApiException> prepareChatGetPermalinkRequest(
            final String token,
            final String channel,
            final String messageTs) {
        return new ApiCall.Builder<ApiResponse<ChatGetPermalinkSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.getPermalink")
                        .queryParam(param -> param.key("token")
                                .value(token))
                        .queryParam(param -> param.key("channel")
                                .value(channel))
                        .queryParam(param -> param.key("message_ts")
                                .value(messageTs))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatGetPermalinkSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Error response when channel cannot be found",
                                (reason, context) -> new ChatGetPermalinkErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Share a me message into a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Optional parameter: Channel to send message to. Can be a public channel,
     *         private group or IM channel. Can be an encoded ID, or a name.
     * @param  text  Optional parameter: Text of the message to send.
     * @return    Returns the ChatMeMessageSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatMeMessageSchema> chatMeMessage(
            final String token,
            final String channel,
            final String text) throws ApiException, IOException {
        return prepareChatMeMessageRequest(token, channel, text).execute();
    }

    /**
     * Share a me message into a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Optional parameter: Channel to send message to. Can be a public channel,
     *         private group or IM channel. Can be an encoded ID, or a name.
     * @param  text  Optional parameter: Text of the message to send.
     * @return    Returns the ChatMeMessageSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatMeMessageSchema>> chatMeMessageAsync(
            final String token,
            final String channel,
            final String text) {
        try {
            return prepareChatMeMessageRequest(token, channel, text).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatMeMessage.
     */
    private ApiCall<ApiResponse<ChatMeMessageSchema>, ApiException> prepareChatMeMessageRequest(
            final String token,
            final String channel,
            final String text) {
        return new ApiCall.Builder<ApiResponse<ChatMeMessageSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.meMessage")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("text")
                                .value(text).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatMeMessageSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ChatMeMessageErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sends an ephemeral message to a user in a channel.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: Channel, private group, or IM channel to send message
     *         to. Can be an encoded ID, or a name.
     * @param  user  Required parameter: `id` of the user who will receive the ephemeral message.
     *         The user should be in the channel specified by the `channel` argument.
     * @param  asUser  Optional parameter: Pass true to post the message as the authed user.
     *         Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to
     *         false.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string.
     * @param  blocks  Optional parameter: A JSON-based array of structured blocks, presented as a
     *         URL-encoded string.
     * @param  iconEmoji  Optional parameter: Emoji to use as the icon for this message. Overrides
     *         `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise
     *         ignored. See [authorship](#authorship) below.
     * @param  iconUrl  Optional parameter: URL to an image to use as the icon for this message.
     *         Must be used in conjunction with `as_user` set to false, otherwise ignored. See
     *         [authorship](#authorship) below.
     * @param  linkNames  Optional parameter: Find and link channel names and usernames.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `none`. See
     *         [below](#formatting).
     * @param  text  Optional parameter: How this field works and whether it is required depends on
     *         other fields you use in your API call. [See below](#text_usage) for more detail.
     * @param  threadTs  Optional parameter: Provide another message's `ts` value to post this
     *         message in a thread. Avoid using a reply's `ts` value; use its parent's value
     *         instead. Ephemeral messages in threads are only shown if there is already an active
     *         thread.
     * @param  username  Optional parameter: Set your bot's user name. Must be used in conjunction
     *         with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
     * @return    Returns the ChatPostEphemeralSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatPostEphemeralSuccessSchema> chatPostEphemeral(
            final String token,
            final String channel,
            final String user,
            final Boolean asUser,
            final String attachments,
            final String blocks,
            final String iconEmoji,
            final String iconUrl,
            final Boolean linkNames,
            final String parse,
            final String text,
            final String threadTs,
            final String username) throws ApiException, IOException {
        return prepareChatPostEphemeralRequest(token, channel, user, asUser, attachments, blocks,
                iconEmoji, iconUrl, linkNames, parse, text, threadTs, username).execute();
    }

    /**
     * Sends an ephemeral message to a user in a channel.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: Channel, private group, or IM channel to send message
     *         to. Can be an encoded ID, or a name.
     * @param  user  Required parameter: `id` of the user who will receive the ephemeral message.
     *         The user should be in the channel specified by the `channel` argument.
     * @param  asUser  Optional parameter: Pass true to post the message as the authed user.
     *         Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to
     *         false.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string.
     * @param  blocks  Optional parameter: A JSON-based array of structured blocks, presented as a
     *         URL-encoded string.
     * @param  iconEmoji  Optional parameter: Emoji to use as the icon for this message. Overrides
     *         `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise
     *         ignored. See [authorship](#authorship) below.
     * @param  iconUrl  Optional parameter: URL to an image to use as the icon for this message.
     *         Must be used in conjunction with `as_user` set to false, otherwise ignored. See
     *         [authorship](#authorship) below.
     * @param  linkNames  Optional parameter: Find and link channel names and usernames.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `none`. See
     *         [below](#formatting).
     * @param  text  Optional parameter: How this field works and whether it is required depends on
     *         other fields you use in your API call. [See below](#text_usage) for more detail.
     * @param  threadTs  Optional parameter: Provide another message's `ts` value to post this
     *         message in a thread. Avoid using a reply's `ts` value; use its parent's value
     *         instead. Ephemeral messages in threads are only shown if there is already an active
     *         thread.
     * @param  username  Optional parameter: Set your bot's user name. Must be used in conjunction
     *         with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
     * @return    Returns the ChatPostEphemeralSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatPostEphemeralSuccessSchema>> chatPostEphemeralAsync(
            final String token,
            final String channel,
            final String user,
            final Boolean asUser,
            final String attachments,
            final String blocks,
            final String iconEmoji,
            final String iconUrl,
            final Boolean linkNames,
            final String parse,
            final String text,
            final String threadTs,
            final String username) {
        try {
            return prepareChatPostEphemeralRequest(token, channel, user, asUser, attachments, blocks,
            iconEmoji, iconUrl, linkNames, parse, text, threadTs, username).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatPostEphemeral.
     */
    private ApiCall<ApiResponse<ChatPostEphemeralSuccessSchema>, ApiException> prepareChatPostEphemeralRequest(
            final String token,
            final String channel,
            final String user,
            final Boolean asUser,
            final String attachments,
            final String blocks,
            final String iconEmoji,
            final String iconUrl,
            final Boolean linkNames,
            final String parse,
            final String text,
            final String threadTs,
            final String username) {
        return new ApiCall.Builder<ApiResponse<ChatPostEphemeralSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.postEphemeral")
                        .formParam(param -> param.key("channel")
                                .value(channel))
                        .formParam(param -> param.key("user")
                                .value(user))
                        .formParam(param -> param.key("as_user")
                                .value(asUser).isRequired(false))
                        .formParam(param -> param.key("attachments")
                                .value(attachments).isRequired(false))
                        .formParam(param -> param.key("blocks")
                                .value(blocks).isRequired(false))
                        .formParam(param -> param.key("icon_emoji")
                                .value(iconEmoji).isRequired(false))
                        .formParam(param -> param.key("icon_url")
                                .value(iconUrl).isRequired(false))
                        .formParam(param -> param.key("link_names")
                                .value(linkNames).isRequired(false))
                        .formParam(param -> param.key("parse")
                                .value(parse).isRequired(false))
                        .formParam(param -> param.key("text")
                                .value(text).isRequired(false))
                        .formParam(param -> param.key("thread_ts")
                                .value(threadTs).isRequired(false))
                        .formParam(param -> param.key("username")
                                .value(username).isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatPostEphemeralSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ChatPostEphemeralErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sends a message to a channel.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: Channel, private group, or IM channel to send message
     *         to. Can be an encoded ID, or a name. See [below](#channels) for more details.
     * @param  asUser  Optional parameter: Pass true to post the message as the authed user, instead
     *         of as a bot. Defaults to false. See [authorship](#authorship) below.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string.
     * @param  blocks  Optional parameter: A JSON-based array of structured blocks, presented as a
     *         URL-encoded string.
     * @param  iconEmoji  Optional parameter: Emoji to use as the icon for this message. Overrides
     *         `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise
     *         ignored. See [authorship](#authorship) below.
     * @param  iconUrl  Optional parameter: URL to an image to use as the icon for this message.
     *         Must be used in conjunction with `as_user` set to false, otherwise ignored. See
     *         [authorship](#authorship) below.
     * @param  linkNames  Optional parameter: Find and link channel names and usernames.
     * @param  mrkdwn  Optional parameter: Disable Slack markup parsing by setting to `false`.
     *         Enabled by default.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `none`. See
     *         [below](#formatting).
     * @param  replyBroadcast  Optional parameter: Used in conjunction with `thread_ts` and
     *         indicates whether reply should be made visible to everyone in the channel or
     *         conversation. Defaults to `false`.
     * @param  text  Optional parameter: How this field works and whether it is required depends on
     *         other fields you use in your API call. [See below](#text_usage) for more detail.
     * @param  threadTs  Optional parameter: Provide another message's `ts` value to make this
     *         message a reply. Avoid using a reply's `ts` value; use its parent instead.
     * @param  unfurlLinks  Optional parameter: Pass true to enable unfurling of primarily
     *         text-based content.
     * @param  unfurlMedia  Optional parameter: Pass false to disable unfurling of media content.
     * @param  username  Optional parameter: Set your bot's user name. Must be used in conjunction
     *         with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
     * @return    Returns the ChatPostMessageSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatPostMessageSuccessSchema> chatPostMessage(
            final String token,
            final String channel,
            final String asUser,
            final String attachments,
            final String blocks,
            final String iconEmoji,
            final String iconUrl,
            final Boolean linkNames,
            final Boolean mrkdwn,
            final String parse,
            final Boolean replyBroadcast,
            final String text,
            final String threadTs,
            final Boolean unfurlLinks,
            final Boolean unfurlMedia,
            final String username) throws ApiException, IOException {
        return prepareChatPostMessageRequest(token, channel, asUser, attachments, blocks, iconEmoji,
                iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks,
                unfurlMedia, username).execute();
    }

    /**
     * Sends a message to a channel.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: Channel, private group, or IM channel to send message
     *         to. Can be an encoded ID, or a name. See [below](#channels) for more details.
     * @param  asUser  Optional parameter: Pass true to post the message as the authed user, instead
     *         of as a bot. Defaults to false. See [authorship](#authorship) below.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string.
     * @param  blocks  Optional parameter: A JSON-based array of structured blocks, presented as a
     *         URL-encoded string.
     * @param  iconEmoji  Optional parameter: Emoji to use as the icon for this message. Overrides
     *         `icon_url`. Must be used in conjunction with `as_user` set to `false`, otherwise
     *         ignored. See [authorship](#authorship) below.
     * @param  iconUrl  Optional parameter: URL to an image to use as the icon for this message.
     *         Must be used in conjunction with `as_user` set to false, otherwise ignored. See
     *         [authorship](#authorship) below.
     * @param  linkNames  Optional parameter: Find and link channel names and usernames.
     * @param  mrkdwn  Optional parameter: Disable Slack markup parsing by setting to `false`.
     *         Enabled by default.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `none`. See
     *         [below](#formatting).
     * @param  replyBroadcast  Optional parameter: Used in conjunction with `thread_ts` and
     *         indicates whether reply should be made visible to everyone in the channel or
     *         conversation. Defaults to `false`.
     * @param  text  Optional parameter: How this field works and whether it is required depends on
     *         other fields you use in your API call. [See below](#text_usage) for more detail.
     * @param  threadTs  Optional parameter: Provide another message's `ts` value to make this
     *         message a reply. Avoid using a reply's `ts` value; use its parent instead.
     * @param  unfurlLinks  Optional parameter: Pass true to enable unfurling of primarily
     *         text-based content.
     * @param  unfurlMedia  Optional parameter: Pass false to disable unfurling of media content.
     * @param  username  Optional parameter: Set your bot's user name. Must be used in conjunction
     *         with `as_user` set to false, otherwise ignored. See [authorship](#authorship) below.
     * @return    Returns the ChatPostMessageSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatPostMessageSuccessSchema>> chatPostMessageAsync(
            final String token,
            final String channel,
            final String asUser,
            final String attachments,
            final String blocks,
            final String iconEmoji,
            final String iconUrl,
            final Boolean linkNames,
            final Boolean mrkdwn,
            final String parse,
            final Boolean replyBroadcast,
            final String text,
            final String threadTs,
            final Boolean unfurlLinks,
            final Boolean unfurlMedia,
            final String username) {
        try {
            return prepareChatPostMessageRequest(token, channel, asUser, attachments, blocks, iconEmoji,
            iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks,
            unfurlMedia, username).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatPostMessage.
     */
    private ApiCall<ApiResponse<ChatPostMessageSuccessSchema>, ApiException> prepareChatPostMessageRequest(
            final String token,
            final String channel,
            final String asUser,
            final String attachments,
            final String blocks,
            final String iconEmoji,
            final String iconUrl,
            final Boolean linkNames,
            final Boolean mrkdwn,
            final String parse,
            final Boolean replyBroadcast,
            final String text,
            final String threadTs,
            final Boolean unfurlLinks,
            final Boolean unfurlMedia,
            final String username) {
        return new ApiCall.Builder<ApiResponse<ChatPostMessageSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.postMessage")
                        .formParam(param -> param.key("channel")
                                .value(channel))
                        .formParam(param -> param.key("as_user")
                                .value(asUser).isRequired(false))
                        .formParam(param -> param.key("attachments")
                                .value(attachments).isRequired(false))
                        .formParam(param -> param.key("blocks")
                                .value(blocks).isRequired(false))
                        .formParam(param -> param.key("icon_emoji")
                                .value(iconEmoji).isRequired(false))
                        .formParam(param -> param.key("icon_url")
                                .value(iconUrl).isRequired(false))
                        .formParam(param -> param.key("link_names")
                                .value(linkNames).isRequired(false))
                        .formParam(param -> param.key("mrkdwn")
                                .value(mrkdwn).isRequired(false))
                        .formParam(param -> param.key("parse")
                                .value(parse).isRequired(false))
                        .formParam(param -> param.key("reply_broadcast")
                                .value(replyBroadcast).isRequired(false))
                        .formParam(param -> param.key("text")
                                .value(text).isRequired(false))
                        .formParam(param -> param.key("thread_ts")
                                .value(threadTs).isRequired(false))
                        .formParam(param -> param.key("unfurl_links")
                                .value(unfurlLinks).isRequired(false))
                        .formParam(param -> param.key("unfurl_media")
                                .value(unfurlMedia).isRequired(false))
                        .formParam(param -> param.key("username")
                                .value(username).isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatPostMessageSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response if too many attachments are included",
                                (reason, context) -> new ChatPostMessageErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Schedules a message to be sent to a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Optional parameter: Channel, private group, or DM channel to send message
     *         to. Can be an encoded ID, or a name. See [below](#channels) for more details.
     * @param  text  Optional parameter: How this field works and whether it is required depends on
     *         other fields you use in your API call. [See below](#text_usage) for more detail.
     * @param  postAt  Optional parameter: Unix EPOCH timestamp of time in future to send the
     *         message.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `none`. See
     *         [chat.postMessage](chat.postMessage#formatting).
     * @param  asUser  Optional parameter: Pass true to post the message as the authed user, instead
     *         of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
     * @param  linkNames  Optional parameter: Find and link channel names and usernames.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string.
     * @param  blocks  Optional parameter: A JSON-based array of structured blocks, presented as a
     *         URL-encoded string.
     * @param  unfurlLinks  Optional parameter: Pass true to enable unfurling of primarily
     *         text-based content.
     * @param  unfurlMedia  Optional parameter: Pass false to disable unfurling of media content.
     * @param  threadTs  Optional parameter: Provide another message's `ts` value to make this
     *         message a reply. Avoid using a reply's `ts` value; use its parent instead.
     * @param  replyBroadcast  Optional parameter: Used in conjunction with `thread_ts` and
     *         indicates whether reply should be made visible to everyone in the channel or
     *         conversation. Defaults to `false`.
     * @return    Returns the ChatScheduleMessageSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatScheduleMessageSuccessSchema> chatScheduleMessage(
            final String token,
            final String channel,
            final String text,
            final String postAt,
            final String parse,
            final Boolean asUser,
            final Boolean linkNames,
            final String attachments,
            final String blocks,
            final Boolean unfurlLinks,
            final Boolean unfurlMedia,
            final Double threadTs,
            final Boolean replyBroadcast) throws ApiException, IOException {
        return prepareChatScheduleMessageRequest(token, channel, text, postAt, parse, asUser,
                linkNames, attachments, blocks, unfurlLinks, unfurlMedia, threadTs,
                replyBroadcast).execute();
    }

    /**
     * Schedules a message to be sent to a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Optional parameter: Channel, private group, or DM channel to send message
     *         to. Can be an encoded ID, or a name. See [below](#channels) for more details.
     * @param  text  Optional parameter: How this field works and whether it is required depends on
     *         other fields you use in your API call. [See below](#text_usage) for more detail.
     * @param  postAt  Optional parameter: Unix EPOCH timestamp of time in future to send the
     *         message.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `none`. See
     *         [chat.postMessage](chat.postMessage#formatting).
     * @param  asUser  Optional parameter: Pass true to post the message as the authed user, instead
     *         of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship).
     * @param  linkNames  Optional parameter: Find and link channel names and usernames.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string.
     * @param  blocks  Optional parameter: A JSON-based array of structured blocks, presented as a
     *         URL-encoded string.
     * @param  unfurlLinks  Optional parameter: Pass true to enable unfurling of primarily
     *         text-based content.
     * @param  unfurlMedia  Optional parameter: Pass false to disable unfurling of media content.
     * @param  threadTs  Optional parameter: Provide another message's `ts` value to make this
     *         message a reply. Avoid using a reply's `ts` value; use its parent instead.
     * @param  replyBroadcast  Optional parameter: Used in conjunction with `thread_ts` and
     *         indicates whether reply should be made visible to everyone in the channel or
     *         conversation. Defaults to `false`.
     * @return    Returns the ChatScheduleMessageSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatScheduleMessageSuccessSchema>> chatScheduleMessageAsync(
            final String token,
            final String channel,
            final String text,
            final String postAt,
            final String parse,
            final Boolean asUser,
            final Boolean linkNames,
            final String attachments,
            final String blocks,
            final Boolean unfurlLinks,
            final Boolean unfurlMedia,
            final Double threadTs,
            final Boolean replyBroadcast) {
        try {
            return prepareChatScheduleMessageRequest(token, channel, text, postAt, parse, asUser, linkNames,
            attachments, blocks, unfurlLinks, unfurlMedia, threadTs, replyBroadcast).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatScheduleMessage.
     */
    private ApiCall<ApiResponse<ChatScheduleMessageSuccessSchema>, ApiException> prepareChatScheduleMessageRequest(
            final String token,
            final String channel,
            final String text,
            final String postAt,
            final String parse,
            final Boolean asUser,
            final Boolean linkNames,
            final String attachments,
            final String blocks,
            final Boolean unfurlLinks,
            final Boolean unfurlMedia,
            final Double threadTs,
            final Boolean replyBroadcast) {
        return new ApiCall.Builder<ApiResponse<ChatScheduleMessageSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.scheduleMessage")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("text")
                                .value(text).isRequired(false))
                        .formParam(param -> param.key("post_at")
                                .value(postAt).isRequired(false))
                        .formParam(param -> param.key("parse")
                                .value(parse).isRequired(false))
                        .formParam(param -> param.key("as_user")
                                .value(asUser).isRequired(false))
                        .formParam(param -> param.key("link_names")
                                .value(linkNames).isRequired(false))
                        .formParam(param -> param.key("attachments")
                                .value(attachments).isRequired(false))
                        .formParam(param -> param.key("blocks")
                                .value(blocks).isRequired(false))
                        .formParam(param -> param.key("unfurl_links")
                                .value(unfurlLinks).isRequired(false))
                        .formParam(param -> param.key("unfurl_media")
                                .value(unfurlMedia).isRequired(false))
                        .formParam(param -> param.key("thread_ts")
                                .value(threadTs).isRequired(false))
                        .formParam(param -> param.key("reply_broadcast")
                                .value(replyBroadcast).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatScheduleMessageSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response if the `post_at` is invalid (ex. in the past or too far into the future)",
                                (reason, context) -> new ChatScheduleMessageErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Provide custom unfurl behavior for user-posted URLs.
     * @param  token  Required parameter: Authentication token. Requires scope: `links:write`
     * @param  channel  Required parameter: Channel ID of the message
     * @param  ts  Required parameter: Timestamp of the message to add unfurl behavior to.
     * @param  unfurls  Optional parameter: URL-encoded JSON map with keys set to URLs featured in
     *         the the message, pointing to their unfurl blocks or message attachments.
     * @param  userAuthMessage  Optional parameter: Provide a simply-formatted string to send as an
     *         ephemeral message to the user as invitation to authenticate further and enable full
     *         unfurling behavior
     * @param  userAuthRequired  Optional parameter: Set to `true` or `1` to indicate the user must
     *         install your Slack app to trigger unfurls for this domain
     * @param  userAuthUrl  Optional parameter: Send users to this custom URL where they will
     *         complete authentication in your app to fully trigger unfurling. Value should be
     *         properly URL-encoded.
     * @return    Returns the ChatUnfurlSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatUnfurlSuccessSchema> chatUnfurl(
            final String token,
            final String channel,
            final String ts,
            final String unfurls,
            final String userAuthMessage,
            final Boolean userAuthRequired,
            final String userAuthUrl) throws ApiException, IOException {
        return prepareChatUnfurlRequest(token, channel, ts, unfurls, userAuthMessage,
                userAuthRequired, userAuthUrl).execute();
    }

    /**
     * Provide custom unfurl behavior for user-posted URLs.
     * @param  token  Required parameter: Authentication token. Requires scope: `links:write`
     * @param  channel  Required parameter: Channel ID of the message
     * @param  ts  Required parameter: Timestamp of the message to add unfurl behavior to.
     * @param  unfurls  Optional parameter: URL-encoded JSON map with keys set to URLs featured in
     *         the the message, pointing to their unfurl blocks or message attachments.
     * @param  userAuthMessage  Optional parameter: Provide a simply-formatted string to send as an
     *         ephemeral message to the user as invitation to authenticate further and enable full
     *         unfurling behavior
     * @param  userAuthRequired  Optional parameter: Set to `true` or `1` to indicate the user must
     *         install your Slack app to trigger unfurls for this domain
     * @param  userAuthUrl  Optional parameter: Send users to this custom URL where they will
     *         complete authentication in your app to fully trigger unfurling. Value should be
     *         properly URL-encoded.
     * @return    Returns the ChatUnfurlSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatUnfurlSuccessSchema>> chatUnfurlAsync(
            final String token,
            final String channel,
            final String ts,
            final String unfurls,
            final String userAuthMessage,
            final Boolean userAuthRequired,
            final String userAuthUrl) {
        try {
            return prepareChatUnfurlRequest(token, channel, ts, unfurls, userAuthMessage, userAuthRequired,
            userAuthUrl).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatUnfurl.
     */
    private ApiCall<ApiResponse<ChatUnfurlSuccessSchema>, ApiException> prepareChatUnfurlRequest(
            final String token,
            final String channel,
            final String ts,
            final String unfurls,
            final String userAuthMessage,
            final Boolean userAuthRequired,
            final String userAuthUrl) {
        return new ApiCall.Builder<ApiResponse<ChatUnfurlSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.unfurl")
                        .formParam(param -> param.key("channel")
                                .value(channel))
                        .formParam(param -> param.key("ts")
                                .value(ts))
                        .formParam(param -> param.key("unfurls")
                                .value(unfurls).isRequired(false))
                        .formParam(param -> param.key("user_auth_message")
                                .value(userAuthMessage).isRequired(false))
                        .formParam(param -> param.key("user_auth_required")
                                .value(userAuthRequired).isRequired(false))
                        .formParam(param -> param.key("user_auth_url")
                                .value(userAuthUrl).isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatUnfurlSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ChatUnfurlErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates a message.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: Channel containing the message to be updated.
     * @param  ts  Required parameter: Timestamp of the message to be updated.
     * @param  asUser  Optional parameter: Pass true to update the message as the authed user. [Bot
     *         users](/bot-users) in this context are considered authed users.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string. This field is required when not presenting `text`.
     *         If you don't include this field, the message's previous `attachments` will be
     *         retained. To remove previous `attachments`, include an empty array for this field.
     * @param  blocks  Optional parameter: A JSON-based array of [structured
     *         blocks](/block-kit/building), presented as a URL-encoded string. If you don't include
     *         this field, the message's previous `blocks` will be retained. To remove previous
     *         `blocks`, include an empty array for this field.
     * @param  linkNames  Optional parameter: Find and link channel names and usernames. Defaults to
     *         `none`. If you do not specify a value for this field, the original value set for the
     *         message will be overwritten with the default, `none`.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `client`,
     *         unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a
     *         value for this field, the original value set for the message will be overwritten with
     *         the default, `client`.
     * @param  text  Optional parameter: New text for the message, using the [default formatting
     *         rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or
     *         `attachments`.
     * @return    Returns the ChatUpdateSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ChatUpdateSuccessSchema> chatUpdate(
            final String token,
            final String channel,
            final String ts,
            final String asUser,
            final String attachments,
            final String blocks,
            final String linkNames,
            final String parse,
            final String text) throws ApiException, IOException {
        return prepareChatUpdateRequest(token, channel, ts, asUser, attachments, blocks, linkNames,
                parse, text).execute();
    }

    /**
     * Updates a message.
     * @param  token  Required parameter: Authentication token. Requires scope: `chat:write`
     * @param  channel  Required parameter: Channel containing the message to be updated.
     * @param  ts  Required parameter: Timestamp of the message to be updated.
     * @param  asUser  Optional parameter: Pass true to update the message as the authed user. [Bot
     *         users](/bot-users) in this context are considered authed users.
     * @param  attachments  Optional parameter: A JSON-based array of structured attachments,
     *         presented as a URL-encoded string. This field is required when not presenting `text`.
     *         If you don't include this field, the message's previous `attachments` will be
     *         retained. To remove previous `attachments`, include an empty array for this field.
     * @param  blocks  Optional parameter: A JSON-based array of [structured
     *         blocks](/block-kit/building), presented as a URL-encoded string. If you don't include
     *         this field, the message's previous `blocks` will be retained. To remove previous
     *         `blocks`, include an empty array for this field.
     * @param  linkNames  Optional parameter: Find and link channel names and usernames. Defaults to
     *         `none`. If you do not specify a value for this field, the original value set for the
     *         message will be overwritten with the default, `none`.
     * @param  parse  Optional parameter: Change how messages are treated. Defaults to `client`,
     *         unlike `chat.postMessage`. Accepts either `none` or `full`. If you do not specify a
     *         value for this field, the original value set for the message will be overwritten with
     *         the default, `client`.
     * @param  text  Optional parameter: New text for the message, using the [default formatting
     *         rules](/reference/surfaces/formatting). It's not required when presenting `blocks` or
     *         `attachments`.
     * @return    Returns the ChatUpdateSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ChatUpdateSuccessSchema>> chatUpdateAsync(
            final String token,
            final String channel,
            final String ts,
            final String asUser,
            final String attachments,
            final String blocks,
            final String linkNames,
            final String parse,
            final String text) {
        try {
            return prepareChatUpdateRequest(token, channel, ts, asUser, attachments, blocks, linkNames,
            parse, text).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for chatUpdate.
     */
    private ApiCall<ApiResponse<ChatUpdateSuccessSchema>, ApiException> prepareChatUpdateRequest(
            final String token,
            final String channel,
            final String ts,
            final String asUser,
            final String attachments,
            final String blocks,
            final String linkNames,
            final String parse,
            final String text) {
        return new ApiCall.Builder<ApiResponse<ChatUpdateSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/chat.update")
                        .formParam(param -> param.key("channel")
                                .value(channel))
                        .formParam(param -> param.key("ts")
                                .value(ts))
                        .formParam(param -> param.key("as_user")
                                .value(asUser).isRequired(false))
                        .formParam(param -> param.key("attachments")
                                .value(attachments).isRequired(false))
                        .formParam(param -> param.key("blocks")
                                .value(blocks).isRequired(false))
                        .formParam(param -> param.key("link_names")
                                .value(linkNames).isRequired(false))
                        .formParam(param -> param.key("parse")
                                .value(parse).isRequired(false))
                        .formParam(param -> param.key("text")
                                .value(text).isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ChatUpdateSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ChatUpdateErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}