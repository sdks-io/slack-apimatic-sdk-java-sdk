/*
 * SlackWebApiLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.slack.apis;

import com.slack.ApiHelper;
import com.slack.Server;
import com.slack.exceptions.ApiException;
import com.slack.exceptions.ConversationsArchiveErrorSchemaException;
import com.slack.exceptions.ConversationsCloseErrorSchemaException;
import com.slack.exceptions.ConversationsCreateErrorSchemaException;
import com.slack.exceptions.ConversationsHistoryErrorSchemaException;
import com.slack.exceptions.ConversationsInfoErrorSchemaException;
import com.slack.exceptions.ConversationsInviteErrorSchema1Exception;
import com.slack.exceptions.ConversationsJoinErrorSchemaException;
import com.slack.exceptions.ConversationsKickErrorSchemaException;
import com.slack.exceptions.ConversationsLeaveErrorSchemaException;
import com.slack.exceptions.ConversationsListErrorSchemaException;
import com.slack.exceptions.ConversationsMarkErrorSchemaException;
import com.slack.exceptions.ConversationsMembersErrorSchemaException;
import com.slack.exceptions.ConversationsOpenErrorSchemaException;
import com.slack.exceptions.ConversationsRenameErrorSchemaException;
import com.slack.exceptions.ConversationsRepliesErrorSchemaException;
import com.slack.exceptions.ConversationsSetPurposeErrorSchemaException;
import com.slack.exceptions.ConversationsSetTopicErrorSchemaException;
import com.slack.exceptions.ConversationsUnarchiveErrorSchemaException;
import com.slack.http.request.HttpMethod;
import com.slack.http.response.ApiResponse;
import com.slack.models.ConversationsArchiveSuccessSchema;
import com.slack.models.ConversationsCloseSuccessSchema;
import com.slack.models.ConversationsCreateSuccessSchema;
import com.slack.models.ConversationsHistorySuccessSchema;
import com.slack.models.ConversationsInfoSuccessSchema;
import com.slack.models.ConversationsInviteErrorSchema;
import com.slack.models.ConversationsJoinSuccessSchema;
import com.slack.models.ConversationsKickSuccessSchema;
import com.slack.models.ConversationsLeaveSuccessSchema;
import com.slack.models.ConversationsListSuccessSchema;
import com.slack.models.ConversationsMarkSuccessSchema;
import com.slack.models.ConversationsMembersSuccessSchema;
import com.slack.models.ConversationsOpenSuccessSchema;
import com.slack.models.ConversationsRenameSuccessSchema;
import com.slack.models.ConversationsRepliesSuccessSchema;
import com.slack.models.ConversationsSetPurposeSuccessSchema;
import com.slack.models.ConversationsSetTopicSuccessSchema;
import com.slack.models.ConversationsUnarchiveSuccessSchema;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import io.apimatic.coreinterfaces.http.request.ResponseClassType;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class ConversationsApi extends BaseApi {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public ConversationsApi(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Archives a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to archive
     * @return    Returns the ConversationsArchiveSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsArchiveSuccessSchema> conversationsArchive(
            final String token,
            final String channel) throws ApiException, IOException {
        return prepareConversationsArchiveRequest(token, channel).execute();
    }

    /**
     * Archives a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to archive
     * @return    Returns the ConversationsArchiveSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsArchiveSuccessSchema>> conversationsArchiveAsync(
            final String token,
            final String channel) {
        try {
            return prepareConversationsArchiveRequest(token, channel).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsArchive.
     */
    private ApiCall<ApiResponse<ConversationsArchiveSuccessSchema>, ApiException> prepareConversationsArchiveRequest(
            final String token,
            final String channel) {
        return new ApiCall.Builder<ApiResponse<ConversationsArchiveSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.archive")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsArchiveSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsArchiveErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Closes a direct message or multi-person direct message.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to close.
     * @return    Returns the ConversationsCloseSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsCloseSuccessSchema> conversationsClose(
            final String token,
            final String channel) throws ApiException, IOException {
        return prepareConversationsCloseRequest(token, channel).execute();
    }

    /**
     * Closes a direct message or multi-person direct message.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to close.
     * @return    Returns the ConversationsCloseSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsCloseSuccessSchema>> conversationsCloseAsync(
            final String token,
            final String channel) {
        try {
            return prepareConversationsCloseRequest(token, channel).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsClose.
     */
    private ApiCall<ApiResponse<ConversationsCloseSuccessSchema>, ApiException> prepareConversationsCloseRequest(
            final String token,
            final String channel) {
        return new ApiCall.Builder<ApiResponse<ConversationsCloseSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.close")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsCloseSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsCloseErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Initiates a public or private channel-based conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  name  Optional parameter: Name of the public or private channel to create
     * @param  isPrivate  Optional parameter: Create a private channel instead of a public one
     * @return    Returns the ConversationsCreateSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsCreateSuccessSchema> conversationsCreate(
            final String token,
            final String name,
            final Boolean isPrivate) throws ApiException, IOException {
        return prepareConversationsCreateRequest(token, name, isPrivate).execute();
    }

    /**
     * Initiates a public or private channel-based conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  name  Optional parameter: Name of the public or private channel to create
     * @param  isPrivate  Optional parameter: Create a private channel instead of a public one
     * @return    Returns the ConversationsCreateSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsCreateSuccessSchema>> conversationsCreateAsync(
            final String token,
            final String name,
            final Boolean isPrivate) {
        try {
            return prepareConversationsCreateRequest(token, name, isPrivate).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsCreate.
     */
    private ApiCall<ApiResponse<ConversationsCreateSuccessSchema>, ApiException> prepareConversationsCreateRequest(
            final String token,
            final String name,
            final Boolean isPrivate) {
        return new ApiCall.Builder<ApiResponse<ConversationsCreateSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.create")
                        .formParam(param -> param.key("name")
                                .value(name).isRequired(false))
                        .formParam(param -> param.key("is_private")
                                .value(isPrivate).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsCreateSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response when name already in use",
                                (reason, context) -> new ConversationsCreateErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Fetches a conversation's history of messages and events.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:history`
     * @param  channel  Optional parameter: Conversation ID to fetch history for.
     * @param  latest  Optional parameter: End of time range of messages to include in results.
     * @param  oldest  Optional parameter: Start of time range of messages to include in results.
     * @param  inclusive  Optional parameter: Include messages with latest or oldest timestamp in
     *         results only when either timestamp is specified.
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the users list hasn't
     *         been reached.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsHistorySuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsHistorySuccessSchema> conversationsHistory(
            final String token,
            final String channel,
            final Double latest,
            final Double oldest,
            final Boolean inclusive,
            final Integer limit,
            final String cursor) throws ApiException, IOException {
        return prepareConversationsHistoryRequest(token, channel, latest, oldest, inclusive, limit,
                cursor).execute();
    }

    /**
     * Fetches a conversation's history of messages and events.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:history`
     * @param  channel  Optional parameter: Conversation ID to fetch history for.
     * @param  latest  Optional parameter: End of time range of messages to include in results.
     * @param  oldest  Optional parameter: Start of time range of messages to include in results.
     * @param  inclusive  Optional parameter: Include messages with latest or oldest timestamp in
     *         results only when either timestamp is specified.
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the users list hasn't
     *         been reached.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsHistorySuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsHistorySuccessSchema>> conversationsHistoryAsync(
            final String token,
            final String channel,
            final Double latest,
            final Double oldest,
            final Boolean inclusive,
            final Integer limit,
            final String cursor) {
        try {
            return prepareConversationsHistoryRequest(token, channel, latest, oldest, inclusive, limit,
            cursor).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsHistory.
     */
    private ApiCall<ApiResponse<ConversationsHistorySuccessSchema>, ApiException> prepareConversationsHistoryRequest(
            final String token,
            final String channel,
            final Double latest,
            final Double oldest,
            final Boolean inclusive,
            final Integer limit,
            final String cursor) {
        return new ApiCall.Builder<ApiResponse<ConversationsHistorySuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.history")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .queryParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .queryParam(param -> param.key("latest")
                                .value(latest).isRequired(false))
                        .queryParam(param -> param.key("oldest")
                                .value(oldest).isRequired(false))
                        .queryParam(param -> param.key("inclusive")
                                .value(inclusive).isRequired(false))
                        .queryParam(param -> param.key("limit")
                                .value(limit).isRequired(false))
                        .queryParam(param -> param.key("cursor")
                                .value(cursor).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsHistorySuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsHistoryErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Retrieve information about a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope: `conversations:read`
     * @param  channel  Optional parameter: Conversation ID to learn more about
     * @param  includeLocale  Optional parameter: Set this to `true` to receive the locale for this
     *         conversation. Defaults to `false`
     * @param  includeNumMembers  Optional parameter: Set to `true` to include the member count for
     *         the specified conversation. Defaults to `false`
     * @return    Returns the ConversationsInfoSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsInfoSuccessSchema> conversationsInfo(
            final String token,
            final String channel,
            final Boolean includeLocale,
            final Boolean includeNumMembers) throws ApiException, IOException {
        return prepareConversationsInfoRequest(token, channel, includeLocale,
                includeNumMembers).execute();
    }

    /**
     * Retrieve information about a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope: `conversations:read`
     * @param  channel  Optional parameter: Conversation ID to learn more about
     * @param  includeLocale  Optional parameter: Set this to `true` to receive the locale for this
     *         conversation. Defaults to `false`
     * @param  includeNumMembers  Optional parameter: Set to `true` to include the member count for
     *         the specified conversation. Defaults to `false`
     * @return    Returns the ConversationsInfoSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsInfoSuccessSchema>> conversationsInfoAsync(
            final String token,
            final String channel,
            final Boolean includeLocale,
            final Boolean includeNumMembers) {
        try {
            return prepareConversationsInfoRequest(token, channel, includeLocale,
            includeNumMembers).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsInfo.
     */
    private ApiCall<ApiResponse<ConversationsInfoSuccessSchema>, ApiException> prepareConversationsInfoRequest(
            final String token,
            final String channel,
            final Boolean includeLocale,
            final Boolean includeNumMembers) {
        return new ApiCall.Builder<ApiResponse<ConversationsInfoSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.info")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .queryParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .queryParam(param -> param.key("include_locale")
                                .value(includeLocale).isRequired(false))
                        .queryParam(param -> param.key("include_num_members")
                                .value(includeNumMembers).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsInfoSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response when a channel cannot be found",
                                (reason, context) -> new ConversationsInfoErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Invites users to a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: The ID of the public or private channel to invite
     *         user(s) to.
     * @param  users  Optional parameter: A comma separated list of user IDs. Up to 1000 users may
     *         be listed.
     * @return    Returns the ConversationsInviteErrorSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsInviteErrorSchema> conversationsInvite(
            final String token,
            final String channel,
            final String users) throws ApiException, IOException {
        return prepareConversationsInviteRequest(token, channel, users).execute();
    }

    /**
     * Invites users to a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: The ID of the public or private channel to invite
     *         user(s) to.
     * @param  users  Optional parameter: A comma separated list of user IDs. Up to 1000 users may
     *         be listed.
     * @return    Returns the ConversationsInviteErrorSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsInviteErrorSchema>> conversationsInviteAsync(
            final String token,
            final String channel,
            final String users) {
        try {
            return prepareConversationsInviteRequest(token, channel, users).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsInvite.
     */
    private ApiCall<ApiResponse<ConversationsInviteErrorSchema>, ApiException> prepareConversationsInviteRequest(
            final String token,
            final String channel,
            final String users) {
        return new ApiCall.Builder<ApiResponse<ConversationsInviteErrorSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.invite")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("users")
                                .value(users).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsInviteErrorSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response when an invite is attempted on a conversation type that does not support it",
                                (reason, context) -> new ConversationsInviteErrorSchema1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Joins an existing conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope: `channels:write`
     * @param  channel  Optional parameter: ID of conversation to join
     * @return    Returns the ConversationsJoinSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsJoinSuccessSchema> conversationsJoin(
            final String token,
            final String channel) throws ApiException, IOException {
        return prepareConversationsJoinRequest(token, channel).execute();
    }

    /**
     * Joins an existing conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope: `channels:write`
     * @param  channel  Optional parameter: ID of conversation to join
     * @return    Returns the ConversationsJoinSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsJoinSuccessSchema>> conversationsJoinAsync(
            final String token,
            final String channel) {
        try {
            return prepareConversationsJoinRequest(token, channel).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsJoin.
     */
    private ApiCall<ApiResponse<ConversationsJoinSuccessSchema>, ApiException> prepareConversationsJoinRequest(
            final String token,
            final String channel) {
        return new ApiCall.Builder<ApiResponse<ConversationsJoinSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.join")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsJoinSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response if the conversation is archived and cannot be joined",
                                (reason, context) -> new ConversationsJoinErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a user from a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to remove user from.
     * @param  user  Optional parameter: User ID to be removed.
     * @return    Returns the ConversationsKickSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsKickSuccessSchema> conversationsKick(
            final String token,
            final String channel,
            final String user) throws ApiException, IOException {
        return prepareConversationsKickRequest(token, channel, user).execute();
    }

    /**
     * Removes a user from a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to remove user from.
     * @param  user  Optional parameter: User ID to be removed.
     * @return    Returns the ConversationsKickSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsKickSuccessSchema>> conversationsKickAsync(
            final String token,
            final String channel,
            final String user) {
        try {
            return prepareConversationsKickRequest(token, channel, user).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsKick.
     */
    private ApiCall<ApiResponse<ConversationsKickSuccessSchema>, ApiException> prepareConversationsKickRequest(
            final String token,
            final String channel,
            final String user) {
        return new ApiCall.Builder<ApiResponse<ConversationsKickSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.kick")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("user")
                                .value(user).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsKickSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response when you attempt to kick yourself from a channel",
                                (reason, context) -> new ConversationsKickErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Leaves a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to leave
     * @return    Returns the ConversationsLeaveSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsLeaveSuccessSchema> conversationsLeave(
            final String token,
            final String channel) throws ApiException, IOException {
        return prepareConversationsLeaveRequest(token, channel).execute();
    }

    /**
     * Leaves a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to leave
     * @return    Returns the ConversationsLeaveSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsLeaveSuccessSchema>> conversationsLeaveAsync(
            final String token,
            final String channel) {
        try {
            return prepareConversationsLeaveRequest(token, channel).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsLeave.
     */
    private ApiCall<ApiResponse<ConversationsLeaveSuccessSchema>, ApiException> prepareConversationsLeaveRequest(
            final String token,
            final String channel) {
        return new ApiCall.Builder<ApiResponse<ConversationsLeaveSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.leave")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsLeaveSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response when attempting to leave a workspace's \"general\" channel",
                                (reason, context) -> new ConversationsLeaveErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all channels in a Slack team.
     * @param  token  Optional parameter: Authentication token. Requires scope: `conversations:read`
     * @param  excludeArchived  Optional parameter: Set to `true` to exclude archived channels from
     *         the list
     * @param  types  Optional parameter: Mix and match channel types by providing a comma-separated
     *         list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the list hasn't been
     *         reached. Must be an integer no larger than 1000.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsListSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsListSuccessSchema> conversationsList(
            final String token,
            final Boolean excludeArchived,
            final String types,
            final Integer limit,
            final String cursor) throws ApiException, IOException {
        return prepareConversationsListRequest(token, excludeArchived, types, limit,
                cursor).execute();
    }

    /**
     * Lists all channels in a Slack team.
     * @param  token  Optional parameter: Authentication token. Requires scope: `conversations:read`
     * @param  excludeArchived  Optional parameter: Set to `true` to exclude archived channels from
     *         the list
     * @param  types  Optional parameter: Mix and match channel types by providing a comma-separated
     *         list of any combination of `public_channel`, `private_channel`, `mpim`, `im`
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the list hasn't been
     *         reached. Must be an integer no larger than 1000.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsListSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsListSuccessSchema>> conversationsListAsync(
            final String token,
            final Boolean excludeArchived,
            final String types,
            final Integer limit,
            final String cursor) {
        try {
            return prepareConversationsListRequest(token, excludeArchived, types, limit,
            cursor).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsList.
     */
    private ApiCall<ApiResponse<ConversationsListSuccessSchema>, ApiException> prepareConversationsListRequest(
            final String token,
            final Boolean excludeArchived,
            final String types,
            final Integer limit,
            final String cursor) {
        return new ApiCall.Builder<ApiResponse<ConversationsListSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.list")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .queryParam(param -> param.key("exclude_archived")
                                .value(excludeArchived).isRequired(false))
                        .queryParam(param -> param.key("types")
                                .value(types).isRequired(false))
                        .queryParam(param -> param.key("limit")
                                .value(limit).isRequired(false))
                        .queryParam(param -> param.key("cursor")
                                .value(cursor).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsListSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsListErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the read cursor in a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Channel or conversation to set the read cursor for.
     * @param  ts  Optional parameter: Unique identifier of message you want marked as most recently
     *         seen in this conversation.
     * @return    Returns the ConversationsMarkSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsMarkSuccessSchema> conversationsMark(
            final String token,
            final String channel,
            final Double ts) throws ApiException, IOException {
        return prepareConversationsMarkRequest(token, channel, ts).execute();
    }

    /**
     * Sets the read cursor in a channel.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Channel or conversation to set the read cursor for.
     * @param  ts  Optional parameter: Unique identifier of message you want marked as most recently
     *         seen in this conversation.
     * @return    Returns the ConversationsMarkSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsMarkSuccessSchema>> conversationsMarkAsync(
            final String token,
            final String channel,
            final Double ts) {
        try {
            return prepareConversationsMarkRequest(token, channel, ts).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsMark.
     */
    private ApiCall<ApiResponse<ConversationsMarkSuccessSchema>, ApiException> prepareConversationsMarkRequest(
            final String token,
            final String channel,
            final Double ts) {
        return new ApiCall.Builder<ApiResponse<ConversationsMarkSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.mark")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("ts")
                                .value(ts).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsMarkSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsMarkErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Retrieve members of a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope: `conversations:read`
     * @param  channel  Optional parameter: ID of the conversation to retrieve members for
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the users list hasn't
     *         been reached.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsMembersSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsMembersSuccessSchema> conversationsMembers(
            final String token,
            final String channel,
            final Integer limit,
            final String cursor) throws ApiException, IOException {
        return prepareConversationsMembersRequest(token, channel, limit, cursor).execute();
    }

    /**
     * Retrieve members of a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope: `conversations:read`
     * @param  channel  Optional parameter: ID of the conversation to retrieve members for
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the users list hasn't
     *         been reached.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsMembersSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsMembersSuccessSchema>> conversationsMembersAsync(
            final String token,
            final String channel,
            final Integer limit,
            final String cursor) {
        try {
            return prepareConversationsMembersRequest(token, channel, limit, cursor).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsMembers.
     */
    private ApiCall<ApiResponse<ConversationsMembersSuccessSchema>, ApiException> prepareConversationsMembersRequest(
            final String token,
            final String channel,
            final Integer limit,
            final String cursor) {
        return new ApiCall.Builder<ApiResponse<ConversationsMembersSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.members")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .queryParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .queryParam(param -> param.key("limit")
                                .value(limit).isRequired(false))
                        .queryParam(param -> param.key("cursor")
                                .value(cursor).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsMembersSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response when an invalid cursor is provided",
                                (reason, context) -> new ConversationsMembersErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Opens or resumes a direct message or multi-person direct message.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Resume a conversation by supplying an `im` or `mpim`'s
     *         ID. Or provide the `users` field instead.
     * @param  users  Optional parameter: Comma separated lists of users. If only one user is
     *         included, this creates a 1:1 DM. The ordering of the users is preserved whenever a
     *         multi-person direct message is returned. Supply a `channel` when not supplying
     *         `users`.
     * @param  returnIm  Optional parameter: Boolean, indicates you want the full IM channel
     *         definition in the response.
     * @return    Returns the ConversationsOpenSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsOpenSuccessSchema> conversationsOpen(
            final String token,
            final String channel,
            final String users,
            final Boolean returnIm) throws ApiException, IOException {
        return prepareConversationsOpenRequest(token, channel, users, returnIm).execute();
    }

    /**
     * Opens or resumes a direct message or multi-person direct message.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Resume a conversation by supplying an `im` or `mpim`'s
     *         ID. Or provide the `users` field instead.
     * @param  users  Optional parameter: Comma separated lists of users. If only one user is
     *         included, this creates a 1:1 DM. The ordering of the users is preserved whenever a
     *         multi-person direct message is returned. Supply a `channel` when not supplying
     *         `users`.
     * @param  returnIm  Optional parameter: Boolean, indicates you want the full IM channel
     *         definition in the response.
     * @return    Returns the ConversationsOpenSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsOpenSuccessSchema>> conversationsOpenAsync(
            final String token,
            final String channel,
            final String users,
            final Boolean returnIm) {
        try {
            return prepareConversationsOpenRequest(token, channel, users, returnIm).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsOpen.
     */
    private ApiCall<ApiResponse<ConversationsOpenSuccessSchema>, ApiException> prepareConversationsOpenRequest(
            final String token,
            final String channel,
            final String users,
            final Boolean returnIm) {
        return new ApiCall.Builder<ApiResponse<ConversationsOpenSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.open")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("users")
                                .value(users).isRequired(false))
                        .formParam(param -> param.key("return_im")
                                .value(returnIm).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsOpenSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsOpenErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Renames a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to rename
     * @param  name  Optional parameter: New name for conversation.
     * @return    Returns the ConversationsRenameSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsRenameSuccessSchema> conversationsRename(
            final String token,
            final String channel,
            final String name) throws ApiException, IOException {
        return prepareConversationsRenameRequest(token, channel, name).execute();
    }

    /**
     * Renames a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to rename
     * @param  name  Optional parameter: New name for conversation.
     * @return    Returns the ConversationsRenameSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsRenameSuccessSchema>> conversationsRenameAsync(
            final String token,
            final String channel,
            final String name) {
        try {
            return prepareConversationsRenameRequest(token, channel, name).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsRename.
     */
    private ApiCall<ApiResponse<ConversationsRenameSuccessSchema>, ApiException> prepareConversationsRenameRequest(
            final String token,
            final String channel,
            final String name) {
        return new ApiCall.Builder<ApiResponse<ConversationsRenameSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.rename")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("name")
                                .value(name).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsRenameSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response when the calling user is not a member of the conversation",
                                (reason, context) -> new ConversationsRenameErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Retrieve a thread of messages posted to a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:history`
     * @param  channel  Optional parameter: Conversation ID to fetch thread from.
     * @param  ts  Optional parameter: Unique identifier of a thread's parent message. `ts` must be
     *         the timestamp of an existing message with 0 or more replies. If there are no replies
     *         then just the single message referenced by `ts` will return - it is just an ordinary,
     *         unthreaded message.
     * @param  latest  Optional parameter: End of time range of messages to include in results.
     * @param  oldest  Optional parameter: Start of time range of messages to include in results.
     * @param  inclusive  Optional parameter: Include messages with latest or oldest timestamp in
     *         results only when either timestamp is specified.
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the users list hasn't
     *         been reached.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsRepliesSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsRepliesSuccessSchema> conversationsReplies(
            final String token,
            final String channel,
            final Double ts,
            final Double latest,
            final Double oldest,
            final Boolean inclusive,
            final Integer limit,
            final String cursor) throws ApiException, IOException {
        return prepareConversationsRepliesRequest(token, channel, ts, latest, oldest, inclusive,
                limit, cursor).execute();
    }

    /**
     * Retrieve a thread of messages posted to a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:history`
     * @param  channel  Optional parameter: Conversation ID to fetch thread from.
     * @param  ts  Optional parameter: Unique identifier of a thread's parent message. `ts` must be
     *         the timestamp of an existing message with 0 or more replies. If there are no replies
     *         then just the single message referenced by `ts` will return - it is just an ordinary,
     *         unthreaded message.
     * @param  latest  Optional parameter: End of time range of messages to include in results.
     * @param  oldest  Optional parameter: Start of time range of messages to include in results.
     * @param  inclusive  Optional parameter: Include messages with latest or oldest timestamp in
     *         results only when either timestamp is specified.
     * @param  limit  Optional parameter: The maximum number of items to return. Fewer than the
     *         requested number of items may be returned, even if the end of the users list hasn't
     *         been reached.
     * @param  cursor  Optional parameter: Paginate through collections of data by setting the
     *         `cursor` parameter to a `next_cursor` attribute returned by a previous request's
     *         `response_metadata`. Default value fetches the first "page" of the collection. See
     *         [pagination](/docs/pagination) for more detail.
     * @return    Returns the ConversationsRepliesSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsRepliesSuccessSchema>> conversationsRepliesAsync(
            final String token,
            final String channel,
            final Double ts,
            final Double latest,
            final Double oldest,
            final Boolean inclusive,
            final Integer limit,
            final String cursor) {
        try {
            return prepareConversationsRepliesRequest(token, channel, ts, latest, oldest, inclusive, limit,
            cursor).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsReplies.
     */
    private ApiCall<ApiResponse<ConversationsRepliesSuccessSchema>, ApiException> prepareConversationsRepliesRequest(
            final String token,
            final String channel,
            final Double ts,
            final Double latest,
            final Double oldest,
            final Boolean inclusive,
            final Integer limit,
            final String cursor) {
        return new ApiCall.Builder<ApiResponse<ConversationsRepliesSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.replies")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .queryParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .queryParam(param -> param.key("ts")
                                .value(ts).isRequired(false))
                        .queryParam(param -> param.key("latest")
                                .value(latest).isRequired(false))
                        .queryParam(param -> param.key("oldest")
                                .value(oldest).isRequired(false))
                        .queryParam(param -> param.key("inclusive")
                                .value(inclusive).isRequired(false))
                        .queryParam(param -> param.key("limit")
                                .value(limit).isRequired(false))
                        .queryParam(param -> param.key("cursor")
                                .value(cursor).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsRepliesSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsRepliesErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the purpose for a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to set the purpose of
     * @param  purpose  Optional parameter: A new, specialer purpose
     * @return    Returns the ConversationsSetPurposeSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsSetPurposeSuccessSchema> conversationsSetPurpose(
            final String token,
            final String channel,
            final String purpose) throws ApiException, IOException {
        return prepareConversationsSetPurposeRequest(token, channel, purpose).execute();
    }

    /**
     * Sets the purpose for a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to set the purpose of
     * @param  purpose  Optional parameter: A new, specialer purpose
     * @return    Returns the ConversationsSetPurposeSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsSetPurposeSuccessSchema>> conversationsSetPurposeAsync(
            final String token,
            final String channel,
            final String purpose) {
        try {
            return prepareConversationsSetPurposeRequest(token, channel, purpose).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsSetPurpose.
     */
    private ApiCall<ApiResponse<ConversationsSetPurposeSuccessSchema>, ApiException> prepareConversationsSetPurposeRequest(
            final String token,
            final String channel,
            final String purpose) {
        return new ApiCall.Builder<ApiResponse<ConversationsSetPurposeSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.setPurpose")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("purpose")
                                .value(purpose).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsSetPurposeSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsSetPurposeErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the topic for a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to set the topic of
     * @param  topic  Optional parameter: The new topic string. Does not support formatting or
     *         linkification.
     * @return    Returns the ConversationsSetTopicSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsSetTopicSuccessSchema> conversationsSetTopic(
            final String token,
            final String channel,
            final String topic) throws ApiException, IOException {
        return prepareConversationsSetTopicRequest(token, channel, topic).execute();
    }

    /**
     * Sets the topic for a conversation.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: Conversation to set the topic of
     * @param  topic  Optional parameter: The new topic string. Does not support formatting or
     *         linkification.
     * @return    Returns the ConversationsSetTopicSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsSetTopicSuccessSchema>> conversationsSetTopicAsync(
            final String token,
            final String channel,
            final String topic) {
        try {
            return prepareConversationsSetTopicRequest(token, channel, topic).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsSetTopic.
     */
    private ApiCall<ApiResponse<ConversationsSetTopicSuccessSchema>, ApiException> prepareConversationsSetTopicRequest(
            final String token,
            final String channel,
            final String topic) {
        return new ApiCall.Builder<ApiResponse<ConversationsSetTopicSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.setTopic")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .formParam(param -> param.key("topic")
                                .value(topic).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsSetTopicSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsSetTopicErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Reverses conversation archival.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to unarchive
     * @return    Returns the ConversationsUnarchiveSuccessSchema wrapped in ApiResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApiResponse<ConversationsUnarchiveSuccessSchema> conversationsUnarchive(
            final String token,
            final String channel) throws ApiException, IOException {
        return prepareConversationsUnarchiveRequest(token, channel).execute();
    }

    /**
     * Reverses conversation archival.
     * @param  token  Optional parameter: Authentication token. Requires scope:
     *         `conversations:write`
     * @param  channel  Optional parameter: ID of conversation to unarchive
     * @return    Returns the ConversationsUnarchiveSuccessSchema wrapped in ApiResponse response from the API call
     */
    public CompletableFuture<ApiResponse<ConversationsUnarchiveSuccessSchema>> conversationsUnarchiveAsync(
            final String token,
            final String channel) {
        try {
            return prepareConversationsUnarchiveRequest(token, channel).executeAsync();
        } catch (Exception e) {
            throw new CompletionException(e);
        }
    }

    /**
     * Builds the ApiCall object for conversationsUnarchive.
     */
    private ApiCall<ApiResponse<ConversationsUnarchiveSuccessSchema>, ApiException> prepareConversationsUnarchiveRequest(
            final String token,
            final String channel) {
        return new ApiCall.Builder<ApiResponse<ConversationsUnarchiveSuccessSchema>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/conversations.unarchive")
                        .formParam(param -> param.key("channel")
                                .value(channel).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/x-www-form-urlencoded").isRequired(false))
                        .headerParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("slackAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .responseClassType(ResponseClassType.API_RESPONSE)
                        .apiResponseDeserializer(
                                response -> ApiHelper.deserialize(response, ConversationsUnarchiveSuccessSchema.class))
                        .nullify404(false)
                        .localErrorCase(ErrorCase.DEFAULT,
                                 ErrorCase.setReason("Typical error response",
                                (reason, context) -> new ConversationsUnarchiveErrorSchemaException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}